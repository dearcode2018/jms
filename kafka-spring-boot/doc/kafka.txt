Apache Kafka

指导文档
http://kafka.apache.org/documentation/

1.主题可已配置为不存在时自动创建，一般在研发环境使用.
 # 是否自动创建主题，默认true
 auto.create.topics.enable=true


# 演示-命令行方式
# 生产者: 发送消息
./bin/kafka-console-producer.sh --broker-list 192.168.5.11:9090,192.168.5.11:9091,192.168.5.11:9092 --topic haha1
# 消费者: 接收消息
./bin/kafka-console-consumer.sh --bootstrap-server 192.168.5.11:9090,192.168.5.11:9091,192.168.5.11:9092 --topic haha1 --from-beginning

# 消费者组: 接收消息
./bin/kafka-console-consumer.sh --group <group_id> --bootstrap-server 192.168.5.11:9090,192.168.5.11:9091,192.168.5.11:9092 --topic haha1 --from-beginning

# 检查消费者位置
./bin/kafka-consumer-groups.sh --bootstrap-server 192.168.5.11:9090,192.168.5.11:9091,192.168.5.11:9092 --describe --group consumerGroup001

# 发送和接收消息正常，说明集群正常工作

Kafka集群可以持久的保留已发布的记录，无论它们是否被消耗，配置保留期: log.retention.hours=168
默认7天(168h).
Kafka的性能在数据大小方面是恒定的，因此长时间存储大量的数据不是问题.

Kafka集群 -> 主题(N) -> 分区(N) -> 键(N) -> 数据(1)




生产者
1) 将数据发送到选定主题的指定分区或指定键，达到负载均衡效果
2) 

消费者
1) 保留唯一的元数据是消费者在日志中的偏移或位置
2) 偏移由消费者保存，消费者可以从任意位置开始读取信息
3) 消费者用消费者组名称标记自己，发布到主题的每个记录被传递到消费者组的其中
一个消费者实例，因此消费者组相当于多个具有相同功能的消费者，为消费者负载均衡.
4) 若所有消费者具有不同的消费者组，则每个记录将广播到所有消费者进程
5) 消费者组为消费者集群，由多个进程实例组成
6) 每个消费者实例根据Kafka协议动态托管Kafka集群的分区.若某个消费者实例停机，则其
托管的分区将分发给其他实例
7) Kafka仅提供分区内记录的总订单，而不是主题中多个分区之间的记录，对大多数应用
而言，按分区排序和按键分区数据的能力相结合就足够了. 若需要对记录汇总，可以使用
仅包含一个分区的主题来实现，这意味着每个消费者组只有一个消费者进程.
8) 分区: 每个分区托管于每个消费者组的一个消费者，确保消费者是该分区的唯一读者
并且按顺序使用数据. 注意，消费者组中的消费者不能超过分区，避免消费者太多而闲置


多租户
1) 


Kafak与传统消息系统(队列、发布/订阅)对比
1) 队列的优势: 允许在多个消费者实例上划分数据处理，从而扩展处理
2) 队列的缺点: 一个进程读取已经消失的数据，队列就不是多用户
3) 发布/订阅将数据广播到多个进程，每个消息都发送给每个订阅者，无法扩展处理
4) Kafka消费者组概念概括了队列、发布/订阅的概念，将处理划分为一组进程
5) Kafka优势: 每个主题都有这些属性，可扩展处理而且同时支持多用户(即多个消费者组)
6) 独占消费者: Kafka通过并行性概念-分区来解决独占并行问题
7) 相比其他消息系统解决方案，Kafka具有更好的吞吐量，内置分区、复制和容错功能，
使之成为大规模消息处理程序的理想解决方案.
8) 个人理解: 传统消息系统是无序的有状态的，每个消息需要维持各种状态；kafka是有序的
无状态的，通过分区建立有序，通过检查偏移值来确认消息是否被消费，大大降低消费成本
9) 消费者决定偏移: 便于消费者随意读取历史消息，解决了因为程序错误需要重新消费消息
的问题.


存储系统
1) Kafka将数据写入磁盘，并进行复制以实现容错

连接器
1) 导入数据
4) 导出数据


